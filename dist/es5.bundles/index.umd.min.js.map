{"version":3,"file":"index.umd.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../es5/private/handshake.js","../es5/private/authentication.js","../es5/tokens/fingerprints/data.js","../es5/tokens/cards/auth.js","../es5/tokens/otp/actions.js","../es5/tokens/fingerprints/auth.js","../es5/tokens/iwa/auth.js","../es5/tokens/questions/auth.js","../es5/tokens/otp/auth.js","../es5/tokens/password/actions.js","../es5/tokens/password/auth.js","../es5/tokens/u2f/actions.js","../es5/tokens/u2f/data.js","../es5/tokens/pin/auth.js","../es5/tokens/face/auth.js","../es5/tokens/u2f/client.js","../es5/tokens/u2f/auth.js"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/** @internal */\r\nexport var HandshakeStep;\r\n(function (HandshakeStep) {\r\n    HandshakeStep[HandshakeStep[\"InitClient\"] = 0] = \"InitClient\";\r\n    HandshakeStep[HandshakeStep[\"InitServer\"] = 1] = \"InitServer\";\r\n    HandshakeStep[HandshakeStep[\"ContinueClient\"] = 2] = \"ContinueClient\";\r\n    HandshakeStep[HandshakeStep[\"ContinueServer\"] = 3] = \"ContinueServer\";\r\n})(HandshakeStep || (HandshakeStep = {}));\r\n/** @internal\r\nHolds intermediate authentication workflow data and ensures workflow invariants.\r\nThe authentication workflow essentially is a sequence of steps,\r\nwhere each step passes authentication data either from the client to the server,\r\nor from server to the client.\r\nThe direction of data transfer on each step is determined by availability of\r\ndata from an opposite side:\r\n* if serverData !== null, then next step is on a client side\r\n* if clientData !== null, then next step is on a server side\r\nInvariant: serverData and clientData must be never not-null at the same time\r\n(except on error).\r\n*/\r\nvar HandshakeContext = /** @class */ (function () {\r\n    function HandshakeContext(maxRounds) {\r\n        if (maxRounds === void 0) { maxRounds = 3; }\r\n        this.serverHandle = 0;\r\n        this.clientHandle = 0;\r\n        this.maxRounds = maxRounds;\r\n    }\r\n    HandshakeContext.prototype.nextStep = function () {\r\n        return (!this.serverHandle) ? HandshakeStep.InitServer :\r\n            (!this.clientHandle) ? HandshakeStep.InitClient :\r\n                (!this.clientData && this.serverData) ? HandshakeStep.ContinueClient :\r\n                    (!this.serverData && this.clientData) ? HandshakeStep.ContinueServer :\r\n                        (function () { throw new Error(\"Invalid state\"); })();\r\n    };\r\n    HandshakeContext.prototype.withClientHandle = function (handle) {\r\n        this.clientHandle = handle;\r\n        this.serverData = null;\r\n        return this;\r\n    };\r\n    HandshakeContext.prototype.withServerHandle = function (handle) {\r\n        this.serverHandle = handle;\r\n        this.clientData = null;\r\n        return this;\r\n    };\r\n    HandshakeContext.prototype.withServerData = function (data) {\r\n        this.serverData = data;\r\n        this.clientData = null;\r\n        if (!this.serverData)\r\n            throw new Error(\"No server data\");\r\n        --this.maxRounds; // countdown on every server response\r\n        if (this.maxRounds <= 0)\r\n            throw new Error(\"Handshake stalled\");\r\n        return this;\r\n    };\r\n    HandshakeContext.prototype.withClientData = function (data) {\r\n        this.clientData = data;\r\n        this.serverData = null;\r\n        if (!this.clientData)\r\n            throw new Error(\"No client data\");\r\n        return this;\r\n    };\r\n    return HandshakeContext;\r\n}());\r\nexport { HandshakeContext };\r\n//# sourceMappingURL=handshake.js.map","import { Ticket, User, Credential, Base64Url } from '@digitalpersona/core';\r\nimport { AuthenticationStatus } from '@digitalpersona/services';\r\nimport { HandshakeStep, HandshakeContext } from './handshake';\r\nvar AuthenticationData = /** @class */ (function () {\r\n    function AuthenticationData() {\r\n    }\r\n    return AuthenticationData;\r\n}());\r\nexport { AuthenticationData };\r\n/** @internal */\r\nvar Authenticator = /** @class */ (function () {\r\n    function Authenticator(authService, authClient) {\r\n        this.authService = authService;\r\n        this.authClient = authClient;\r\n        if (!this.authService)\r\n            throw new Error(\"authService\");\r\n    }\r\n    Authenticator.prototype._authenticate = function (identity, credential) {\r\n        return authenticate(identity, credential, this.authService, this.authClient);\r\n    };\r\n    Authenticator.prototype._identify = function (cred) {\r\n        return this.authService\r\n            .Identify(cred)\r\n            .then(function (ticket) { return ticket.jwt; });\r\n    };\r\n    return Authenticator;\r\n}());\r\nexport { Authenticator };\r\n/** @internal */\r\nfunction authenticate(identity, credential, server, client) {\r\n    // When credential data are present, use a direct authentication flow\r\n    if (credential instanceof Credential) {\r\n        if (!identity)\r\n            identity = User.Everyone();\r\n        return (identity instanceof User\r\n            ? server.Authenticate(identity, credential)\r\n            : server.Authenticate(new Ticket(identity), credential)).then(function (ticket) { return ticket.jwt; });\r\n    }\r\n    // When no credential data are present, use a challenge-response authentication flow\r\n    if (!client)\r\n        return Promise.reject(new Error(\"Client\"));\r\n    // Performs one step in an authentication workflow and recursively calls itself for a next step.\r\n    // The workflow finishes when a token obtained, or an error produced.\r\n    var nextStep = function (ctx) {\r\n        switch (ctx.nextStep()) {\r\n            case HandshakeStep.InitClient: {\r\n                return client\r\n                    .init()\r\n                    .then(function (data) { return nextStep(ctx.withClientHandle(data.handle).withClientData(data.data)); });\r\n            }\r\n            case HandshakeStep.InitServer: {\r\n                return ((identity === null) || (identity instanceof User)\r\n                    ? server.CreateAuthentication(identity, credential)\r\n                    : server.CreateAuthentication(new Ticket(identity), credential))\r\n                    .then(function (handle) { return nextStep(ctx.withServerHandle(handle)); });\r\n            }\r\n            case HandshakeStep.ContinueClient: {\r\n                return client\r\n                    .continue(ctx.clientHandle, ctx.serverData)\r\n                    .then(function (clientData) { return nextStep(ctx.withClientData(clientData)); });\r\n            }\r\n            case HandshakeStep.ContinueServer: {\r\n                return server\r\n                    .ContinueAuthentication(ctx.serverHandle, Base64Url.fromUtf8(ctx.clientData))\r\n                    .then(function (result) {\r\n                    switch (result.status) {\r\n                        case AuthenticationStatus.Error:\r\n                            return Promise.reject(new Error(\"Authentication failed\"));\r\n                        case AuthenticationStatus.Continue:\r\n                            return nextStep(ctx.withServerData(result.authData));\r\n                        case AuthenticationStatus.Completed:\r\n                            return Promise.resolve(result.jwt);\r\n                        default:\r\n                            throw new Error(\"Unexpected status\");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    // Start the workflow and extract a token (or throw an error) when ready.\r\n    var context = new HandshakeContext();\r\n    return nextStep(context)\r\n        .catch(function (err) {\r\n        // somehow exception thrown inside u2fApi does not automatically reject the promise, so forcing this here\r\n        return Promise.reject(err);\r\n    })\r\n        .finally(function () {\r\n        if (context.clientHandle)\r\n            client.term(context.clientHandle); // ignore the outcome\r\n        if (context.serverHandle)\r\n            server.DestroyAuthentication(context.serverHandle); // ignore the outcome\r\n    });\r\n}\r\n//# sourceMappingURL=authentication.js.map","/** Finger positions. */\r\nexport var FingerPosition;\r\n(function (FingerPosition) {\r\n    FingerPosition[FingerPosition[\"Unknown\"] = 0] = \"Unknown\";\r\n    FingerPosition[FingerPosition[\"RightThumb\"] = 1] = \"RightThumb\";\r\n    FingerPosition[FingerPosition[\"RightIndex\"] = 2] = \"RightIndex\";\r\n    FingerPosition[FingerPosition[\"RightMiddle\"] = 3] = \"RightMiddle\";\r\n    FingerPosition[FingerPosition[\"RightRing\"] = 4] = \"RightRing\";\r\n    FingerPosition[FingerPosition[\"RightLittle\"] = 5] = \"RightLittle\";\r\n    FingerPosition[FingerPosition[\"LeftThumb\"] = 6] = \"LeftThumb\";\r\n    FingerPosition[FingerPosition[\"LeftIndex\"] = 7] = \"LeftIndex\";\r\n    FingerPosition[FingerPosition[\"LeftMiddle\"] = 8] = \"LeftMiddle\";\r\n    FingerPosition[FingerPosition[\"LeftRing\"] = 9] = \"LeftRing\";\r\n    FingerPosition[FingerPosition[\"LeftLittle\"] = 10] = \"LeftLittle\";\r\n})(FingerPosition || (FingerPosition = {}));\r\n/** A finger enrollment data. */\r\nvar Finger = /** @class */ (function () {\r\n    function Finger(\r\n    /** A finger position. */\r\n    position) {\r\n        this.position = position;\r\n    }\r\n    /** Creates a finger enrollment data object from a plain JSON object. */\r\n    Finger.fromJson = function (json) {\r\n        var obj = json;\r\n        return new Finger(obj.position);\r\n    };\r\n    return Finger;\r\n}());\r\nexport { Finger };\r\n//# sourceMappingURL=data.js.map","import { __extends } from \"tslib\";\r\nimport { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Smart card authentication API.\r\n * Smartcards supports only authentication with PIN. Identification is not supported.\r\n */\r\nvar SmartCardAuth = /** @class */ (function (_super) {\r\n    __extends(SmartCardAuth, _super);\r\n    /** Constructs a new smartcard authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function SmartCardAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using a smartcard.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param cardData - card authentication data received from the card using a PIN.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a smartcard was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    SmartCardAuth.prototype.authenticate = function (identity, cardData) {\r\n        return _super.prototype._authenticate.call(this, identity, new Credential(Credential.SmartCard, cardData));\r\n    };\r\n    return SmartCardAuth;\r\n}(Authenticator));\r\nexport { SmartCardAuth };\r\n/**\r\n * Contactless card authentication API.\r\n * Contactless cards support both authentication and identification.\r\n */\r\nvar ContactlessCardAuth = /** @class */ (function (_super) {\r\n    __extends(ContactlessCardAuth, _super);\r\n    /** Constructs a new contactless authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function ContactlessCardAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using a contactless card.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a contactless card was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    ContactlessCardAuth.prototype.authenticate = function (identity, cardData) {\r\n        return _super.prototype._authenticate.call(this, identity, new Credential(Credential.ContactlessCard, cardData));\r\n    };\r\n    /** Identifies the user with a contactless card.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a subject identity claims (`sub`, `group`, etc)\r\n     * and a claim (`crd`) showing the fact a contactless card was used.\r\n     * Will reject if identification fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    ContactlessCardAuth.prototype.identify = function (cardData) {\r\n        return this.authService\r\n            .Identify(new Credential(Credential.ContactlessCard, cardData))\r\n            .then(function (ticket) { return ticket.jwt; });\r\n    };\r\n    return ContactlessCardAuth;\r\n}(Authenticator));\r\nexport { ContactlessCardAuth };\r\n/**\r\n * Proximity card authentication API.\r\n * Proximity cards support both authentication and identification.\r\n */\r\nvar ProximityCardAuth = /** @class */ (function (_super) {\r\n    __extends(ProximityCardAuth, _super);\r\n    /** Constructs a new proximity authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function ProximityCardAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using a proximimty card.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a proximity card was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    ProximityCardAuth.prototype.authenticate = function (identity, cardData) {\r\n        return _super.prototype._authenticate.call(this, identity, new Credential(Credential.ProximityCard, cardData));\r\n    };\r\n    /** Identifies the user with a proximity card.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a subject identity claims (`sub`, `group`, etc)\r\n     * and a claim (`crd`) showing the fact a proximity card was used.\r\n     * Will reject if identification fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    ProximityCardAuth.prototype.identify = function (cardData) {\r\n        return this.authService\r\n            .Identify(new Credential(Credential.ProximityCard, cardData))\r\n            .then(function (ticket) { return ticket.jwt; });\r\n    };\r\n    return ProximityCardAuth;\r\n}(Authenticator));\r\nexport { ProximityCardAuth };\r\n//# sourceMappingURL=auth.js.map","/**@internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"SendEmailVerificationRequest\"] = 16] = \"SendEmailVerificationRequest\";\r\n    CustomAction[CustomAction[\"SendSMSRequest\"] = 513] = \"SendSMSRequest\";\r\n    CustomAction[CustomAction[\"SendEmailRequest\"] = 514] = \"SendEmailRequest\";\r\n    CustomAction[CustomAction[\"UnlockActiveIdHardwareToken\"] = 515] = \"UnlockActiveIdHardwareToken\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","import { __extends } from \"tslib\";\r\nimport { Utf8, Credential } from '@digitalpersona/core';\r\nimport { Finger } from './data';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Fingerprint authentication API.\r\n * Fingerprints support both authentication and identification.\r\n */\r\nvar FingerprintsAuth = /** @class */ (function (_super) {\r\n    __extends(FingerprintsAuth, _super);\r\n    /** Constructs a new fingerprint authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function FingerprintsAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Reads a list of fingers currently enrolled by the user.\r\n     * @param user - a user name\r\n     * @returns a promise to return a list of enrolled fingers.\r\n     * If no fingers are enrolled, an emty list will be returned.\r\n     * May reject if the user is unknown or in case of an error.\r\n     */\r\n    FingerprintsAuth.prototype.getEnrolledFingers = function (user) {\r\n        return this.authService\r\n            .GetEnrollmentData(user, Credential.Fingerprints)\r\n            .then(function (data) {\r\n            return JSON.parse(Utf8.fromBase64Url(data))\r\n                .map(function (item) { return Finger.fromJson(item); });\r\n        });\r\n    };\r\n    /** Authenticates the user using their fingerprint samples.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param samples - a collection of biometric samples with fingerprint scans.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a fingerprint was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    FingerprintsAuth.prototype.authenticate = function (identity, samples) {\r\n        return _super.prototype._authenticate.call(this, identity, new Credential(Credential.Fingerprints, samples));\r\n    };\r\n    /** Identifies the user with their fingerprints.\r\n     * @param samples - a collection of biometric samples with fingerprint scans.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a fingerprint was used.\r\n     * Will reject if identification fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    FingerprintsAuth.prototype.identify = function (samples) {\r\n        return _super.prototype._identify.call(this, new Credential(Credential.Fingerprints, samples));\r\n    };\r\n    return FingerprintsAuth;\r\n}(Authenticator));\r\nexport { FingerprintsAuth };\r\n//# sourceMappingURL=auth.js.map","import { __extends } from \"tslib\";\r\nimport { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Integrated Windows authentication API.\r\n * IWA support only authentication. Identification is not supported.\r\n */\r\nvar WindowsAuth = /** @class */ (function (_super) {\r\n    __extends(WindowsAuth, _super);\r\n    /** Constructs a new integrated Windows authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function WindowsAuth(authService, client) {\r\n        return _super.call(this, authService, client) || this;\r\n    }\r\n    /** Authenticates using a currently logged Windows user.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a currently logged Window account was used.\r\n     * Will reject if authentication fails.\r\n     */\r\n    WindowsAuth.prototype.authenticate = function () {\r\n        return _super.prototype._authenticate.call(this, null, Credential.IWA);\r\n    };\r\n    return WindowsAuth;\r\n}(Authenticator));\r\nexport { WindowsAuth };\r\n//# sourceMappingURL=auth.js.map","import { __extends } from \"tslib\";\r\nimport { Credential, Utf16, Question } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Security Questions authentication API.\r\n * Security Questions support only authentication. Identification is not supported.\r\n */\r\nvar SecurityQuestionsAuth = /** @class */ (function (_super) {\r\n    __extends(SecurityQuestionsAuth, _super);\r\n    /** Constructs a new Security Questions authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function SecurityQuestionsAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Reads a list of security questions enrolled by the user.\r\n     * @param user - a user's name.\r\n     * @returns a promise to return a list of enrolled questions.\r\n     */\r\n    SecurityQuestionsAuth.prototype.getEnrolledQuestions = function (user) {\r\n        return this.authService\r\n            .GetEnrollmentData(user, Credential.SecurityQuestions)\r\n            .then(function (data) {\r\n            return JSON.parse(Utf16.fromBase64Url(data))\r\n                .map(function (obj) { return Question.fromJson(obj); });\r\n        });\r\n    };\r\n    /** Authenticates the user using user's answers to security questions.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param answers - user's answers to security questions.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a Security Questions were used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    SecurityQuestionsAuth.prototype.authenticate = function (identity, answers) {\r\n        return _super.prototype._authenticate.call(this, identity, new Credential(Credential.SecurityQuestions, { answers: answers }));\r\n    };\r\n    return SecurityQuestionsAuth;\r\n}(Authenticator));\r\nexport { SecurityQuestionsAuth };\r\n//# sourceMappingURL=auth.js.map","import { __extends, __read } from \"tslib\";\r\nimport { User, Ticket, Credential } from '@digitalpersona/core';\r\nimport { CustomAction } from './actions';\r\nimport { Authenticator } from '../../private';\r\nfunction OTP(data) {\r\n    return new Credential(Credential.OneTimePassword, data);\r\n}\r\n/**\r\n * Time-based one-time password (TOTP) authentication API.\r\n * TOTP supports only authentication. Identification is not supported.\r\n */\r\nvar TimeOtpAuth = /** @class */ (function (_super) {\r\n    __extends(TimeOtpAuth, _super);\r\n    /** Constructs a new TOTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function TimeOtpAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using user's TOTP code.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param code - a TOTP code.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    TimeOtpAuth.prototype.authenticate = function (identity, code) {\r\n        return _super.prototype._authenticate.call(this, identity, OTP(code));\r\n    };\r\n    /** Creates a code allowing to unlock a hardware TOTP device when it locks after a number of\r\n     * unsuccessful PIN entries.\r\n     * @param userOrSerialNumber - a username or a locked device serial number.\r\n     * @param challenge - a challenge code provided by the locked device user.\r\n     * @param token - an optional JSON Web Token of the locked device user.\r\n     * @returns a promise to return an unlock code that the locked device user must type in.\r\n     */\r\n    TimeOtpAuth.prototype.getUnlockCode = function (userOrSerialNumber, challenge, token) {\r\n        var _a = __read((userOrSerialNumber instanceof User)\r\n            ? [userOrSerialNumber, null]\r\n            : [User.Anonymous(), userOrSerialNumber], 2), user = _a[0], serialNumber = _a[1];\r\n        return this.authService\r\n            .CustomAction(CustomAction.UnlockActiveIdHardwareToken, new Ticket(token || \"\"), user, OTP({ challenge: challenge, serialNumber: serialNumber }));\r\n    };\r\n    return TimeOtpAuth;\r\n}(Authenticator));\r\nexport { TimeOtpAuth };\r\n/**\r\n * A one-time password authentication API based on Push Notifications (Push OTP).\r\n * Push OTP supports only authentication. Identification is not supported.\r\n */\r\nvar PushOtpAuth = /** @class */ (function (_super) {\r\n    __extends(PushOtpAuth, _super);\r\n    /** Constructs a new Push OTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function PushOtpAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using a Push Notification on the user's registered mobile device.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used. To resolve the promise, the user must accept a Push Notification sent to their\r\n     * mobile device.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     *\r\n     * The user must have a mobile device with a DigitalPersona authenticator app installed and\r\n     * registered in the DigitalPersona server. The user will receive a Push Notification on their\r\n     * mobile device via the app and must accept the notification to proceed. The promise returned\r\n     * by the method will be resolved when the user accepts the notification, otherwise it will reject\r\n     * with a timeout error.\r\n     */\r\n    PushOtpAuth.prototype.authenticate = function (identity) {\r\n        return _super.prototype._authenticate.call(this, identity, OTP(\"push\"));\r\n    };\r\n    return PushOtpAuth;\r\n}(Authenticator));\r\nexport { PushOtpAuth };\r\n/**\r\n * A one-time password authentication API based on a Short Message Service (SMS OTP).\r\n * SMS OTP supports only authentication. Identification is not supported.\r\n */\r\nvar SmsOtpAuth = /** @class */ (function (_super) {\r\n    __extends(SmsOtpAuth, _super);\r\n    /** Constructs a new SMS OTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function SmsOtpAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Sends an SMS challenge with a OTP code to the user's registered mobile device.\r\n     * @param user - a name of the user\r\n     * @returns a promise to send the challenge code.\r\n     */\r\n    SmsOtpAuth.prototype.sendChallenge = function (user) {\r\n        return this.authService\r\n            .CustomAction(CustomAction.SendSMSRequest, Ticket.None(), user, OTP())\r\n            .then();\r\n    };\r\n    /** Authenticates the user using a challenge sent to the user's registered mobile device via SMS.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param code - a code the device user received via SMS challenge.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     *\r\n     * The user must have a mobile device with a phone number registered in the DigitalPersona server.\r\n     * The user will receive an SMS on their mobile device and must type the code sent with the message.\r\n     */\r\n    SmsOtpAuth.prototype.authenticate = function (identity, code) {\r\n        return _super.prototype._authenticate.call(this, identity, OTP(code));\r\n    };\r\n    return SmsOtpAuth;\r\n}(Authenticator));\r\nexport { SmsOtpAuth };\r\n/**\r\n * A one-time password authentication API based on a electronic mail (Email OTP).\r\n * Email OTP supports only authentication. Identification is not supported.\r\n */\r\nvar EmailOtpAuth = /** @class */ (function (_super) {\r\n    __extends(EmailOtpAuth, _super);\r\n    /** Constructs a new Email OTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function EmailOtpAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Sends an e-mail challenge with a OTP code to the user's registered mobile device.\r\n     * @param user - a name of the user\r\n     * @returns a promise to send the challenge code to the registered e-mail address.\r\n     * Will reject if user has no email or in case of any other error.\r\n     * @remarks\r\n     * The user has to have an email registered in their LADP user record in ActiveDirectory or LDS.\r\n     * The server will look for a first entry in a `mail` LDAP atribute of the user record.\r\n     */\r\n    EmailOtpAuth.prototype.sendChallenge = function (user) {\r\n        return this.authService\r\n            .CustomAction(CustomAction.SendEmailRequest, Ticket.None(), user, OTP())\r\n            .then();\r\n    };\r\n    /** Authenticates the user using a challenge sent to the user's registered e-mail address.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param code - a code the user received via e-mail challenge.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    EmailOtpAuth.prototype.authenticate = function (identity, code) {\r\n        return _super.prototype._authenticate.call(this, identity, OTP(code));\r\n    };\r\n    return EmailOtpAuth;\r\n}(Authenticator));\r\nexport { EmailOtpAuth };\r\n//# sourceMappingURL=auth.js.map","/**@internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"PasswordRandomization\"] = 4] = \"PasswordRandomization\";\r\n    CustomAction[CustomAction[\"PasswordReset\"] = 13] = \"PasswordReset\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","import { __extends } from \"tslib\";\r\nimport { Ticket, Credential } from '@digitalpersona/core';\r\nimport { CustomAction } from './actions';\r\nimport { Authenticator } from '../../private';\r\nfunction Password(data) {\r\n    return new Credential(Credential.Password, data);\r\n}\r\n/**\r\n * Password authentication API.\r\n * Passwords support only authentication. Identification is not supported.\r\n */\r\nvar PasswordAuth = /** @class */ (function (_super) {\r\n    __extends(PasswordAuth, _super);\r\n    /** Constructs a new password authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function PasswordAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using user's password.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param password - a user's password.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a password was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    PasswordAuth.prototype.authenticate = function (identity, password) {\r\n        return _super.prototype._authenticate.call(this, identity, Password(password));\r\n    };\r\n    /** Creates a randomized user's password.\r\n     * @param user - a user's name.\r\n     * @param token - a JSON Web Token of a person initiating a password randomization.\r\n     * This person must have a privilege to randomize user passwords.\r\n     * @returns a promise to return a new randomized password.\r\n     * @remarks\r\n     * DigitalPersona AD Server supports password randomization only for ActiveDirectory users.\r\n     * DigitalPersona LDS Server supports password randomization only for DigitalPersona users (formerly \"Altus Users\").\r\n     */\r\n    PasswordAuth.prototype.randomize = function (user, token) {\r\n        return this.authService.CustomAction(CustomAction.PasswordRandomization, new Ticket(token), user, Password());\r\n    };\r\n    /** Resets user's password.\r\n     * @param user - a user's name.\r\n     * @param newPassword - a new password to replace the old password.\r\n     * @param token - a JSON Web Token of a person initiating a password reset.\r\n     * This person must have a privilege to set users' passwords.\r\n     * @returns a promise to reset user's password.\r\n     * @remarks\r\n     * DigitalPersona AD Server supports password randomization only for ActiveDirectory users.\r\n     * DigitalPersona LDS Server supports password randomization only for DigitalPersona users (formerly \"Altus Users\").\r\n     */\r\n    PasswordAuth.prototype.reset = function (user, newPassword, token) {\r\n        return this.authService.CustomAction(CustomAction.PasswordReset, new Ticket(token), user, Password(newPassword))\r\n            .then();\r\n    };\r\n    return PasswordAuth;\r\n}(Authenticator));\r\nexport { PasswordAuth };\r\n//# sourceMappingURL=auth.js.map","/**@internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"RequestAppId\"] = 17] = \"RequestAppId\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","/**@internal\r\n *\r\n */\r\nvar ClientData = /** @class */ (function () {\r\n    function ClientData(type, challenge, origin) {\r\n        this.typ = type;\r\n        this.challenge = challenge;\r\n        this.origin = origin;\r\n    }\r\n    ClientData.prototype.forAuthentication = function (challenge, origin) {\r\n        return new ClientData(\"navigator.id.getAssertion\", challenge, origin);\r\n    };\r\n    ClientData.prototype.forEnrollment = function (challenge, origin) {\r\n        return new ClientData(\"navigator.id.finishEnrollment\", challenge, origin);\r\n    };\r\n    return ClientData;\r\n}());\r\nexport { ClientData };\r\n/**@internal\r\n *\r\n */\r\nexport var HandshakeType;\r\n(function (HandshakeType) {\r\n    HandshakeType[HandshakeType[\"ChallengeRequest\"] = 0] = \"ChallengeRequest\";\r\n    HandshakeType[HandshakeType[\"ChallengeResponse\"] = 1] = \"ChallengeResponse\";\r\n    HandshakeType[HandshakeType[\"AuthenticationRequest\"] = 2] = \"AuthenticationRequest\";\r\n    HandshakeType[HandshakeType[\"AuthenticationResponse\"] = 3] = \"AuthenticationResponse\";\r\n})(HandshakeType || (HandshakeType = {}));\r\nvar HandshakeData = /** @class */ (function () {\r\n    function HandshakeData() {\r\n        this.handshakeType = 0 /* ChallengeRequest */;\r\n    }\r\n    return HandshakeData;\r\n}());\r\nexport { HandshakeData };\r\n//# sourceMappingURL=data.js.map","import { __extends } from \"tslib\";\r\nimport { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Personal Identification Number (PIN) authentication API.\r\n * PIN support only authentication. Identification is not supported.\r\n */\r\nvar PinAuth = /** @class */ (function (_super) {\r\n    __extends(PinAuth, _super);\r\n    /** Constructs a new PIN authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function PinAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using user's PIN code.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param pin - a user's PIN.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a PIN was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    PinAuth.prototype.authenticate = function (identity, pin) {\r\n        return _super.prototype._authenticate.call(this, identity, new Credential(Credential.PIN, pin));\r\n    };\r\n    return PinAuth;\r\n}(Authenticator));\r\nexport { PinAuth };\r\n//# sourceMappingURL=auth.js.map","import { __extends } from \"tslib\";\r\nimport { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Face authentication API.\r\n * Face credential supports authentication. Identification is currently not supported by the server.\r\n */\r\nvar FaceAuth = /** @class */ (function (_super) {\r\n    __extends(FaceAuth, _super);\r\n    /** Constructs a new face authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function FaceAuth(authService) {\r\n        return _super.call(this, authService) || this;\r\n    }\r\n    /** Authenticates the user using their face images.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param samples - a collection of biometric samples with face images.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a face was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    FaceAuth.prototype.authenticate = function (identity, samples) {\r\n        return _super.prototype._authenticate.call(this, identity, new Credential(Credential.Face, samples));\r\n    };\r\n    /** Currently face identification is not supported by the server. */\r\n    FaceAuth.prototype.identify = function (samples) {\r\n        return _super.prototype._identify.call(this, new Credential(Credential.Face, samples));\r\n    };\r\n    return FaceAuth;\r\n}(Authenticator));\r\nexport { FaceAuth };\r\n//# sourceMappingURL=auth.js.map","import * as u2fApi from 'u2f-api';\r\nimport { Utf16, Base64Url } from '@digitalpersona/core';\r\nimport { HandshakeData } from './data';\r\n/**@internal\r\n *\r\n * Implements the client's part of the U2F handshake protocol.\r\n */\r\nvar U2FClient = /** @class */ (function () {\r\n    function U2FClient() {\r\n    }\r\n    U2FClient.prototype.init = function () {\r\n        var challenge = new HandshakeData();\r\n        return Promise.resolve({\r\n            handle: 1,\r\n            data: JSON.stringify(challenge)\r\n        });\r\n    };\r\n    U2FClient.prototype.continue = function (handle, data) {\r\n        var handshake = JSON.parse(data);\r\n        if (handshake.handshakeType != 1 /* ChallengeResponse */)\r\n            return Promise.reject(new Error(\"Unexpected handshake type\"));\r\n        if (!handshake.handshakeData)\r\n            return Promise.reject(new Error(\"No handshake data\"));\r\n        var signRequest = JSON.parse(Utf16.fromBase64Url(handshake.handshakeData));\r\n        return u2fApi\r\n            .sign(signRequest)\r\n            .then(function (signResponse) {\r\n            var handshakeData = JSON.stringify({\r\n                serialNum: \"\",\r\n                version: signRequest.version,\r\n                appId: signRequest.appId,\r\n                signatureData: signResponse.signatureData,\r\n                clientData: signResponse.clientData\r\n            });\r\n            var response = {\r\n                handshakeType: 2 /* AuthenticationRequest */,\r\n                handshakeData: Base64Url.fromUtf16(handshakeData)\r\n            };\r\n            return JSON.stringify(response);\r\n        });\r\n    };\r\n    U2FClient.prototype.term = function (handle) {\r\n        // nothing to do, the handle is surrogate\r\n        return Promise.resolve();\r\n    };\r\n    return U2FClient;\r\n}());\r\nexport { U2FClient };\r\n//# sourceMappingURL=client.js.map","import { __extends } from \"tslib\";\r\nimport * as u2fApi from 'u2f-api';\r\nimport { User, Credential, Ticket } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\nimport { CustomAction } from './actions';\r\nimport { U2FClient } from './client';\r\n/**\r\n * Universal Second Factor (U2F) authentication API.\r\n * U2F support only authentication. Identification is not supported.\r\n */\r\nvar U2FAuth = /** @class */ (function (_super) {\r\n    __extends(U2FAuth, _super);\r\n    /** Constructs a new U2F authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    function U2FAuth(authService) {\r\n        return _super.call(this, authService, new U2FClient()) || this;\r\n    }\r\n    /** Checks is the U2F supported on this platform.\r\n     * @returns a promise to return `true` is the platform supports U2F or `false` otherwise.\r\n     * @remarks\r\n     * To support U2F the user agent must have required API, the web site must use HTTPS,\r\n     * and the DigitalPersona Web Components server must have properly configured U2F AppId\r\n     * for the site.\r\n     */\r\n    U2FAuth.isSupported = function () {\r\n        return u2fApi.isSupported();\r\n    };\r\n    /** Reads U2F AppID endpoint URL.\r\n     * @returns a promise to return a U2F AppID endpoint URL.\r\n     */\r\n    U2FAuth.prototype.getAppId = function () {\r\n        return this.authService.CustomAction(CustomAction.RequestAppId, Ticket.None(), User.Anonymous(), new Credential(Credential.U2F, \"\")).then(function (data) {\r\n            return JSON.parse(data).AppId;\r\n        });\r\n    };\r\n    /** Authenticates the user using a user's registered U2F token (FIDO token).\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a U2F was used. To resolve the promise, the user must touch the U2F token when prompted.\r\n     * Will reject if authentication fails or times out.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     *\r\n     * The user must have a U2F (FIDO) token enrolled in the DigitalPersona server.\r\n     * The user should insert the token and activate it using a touch or pressing a device button.\r\n     * The promise returned by the method will be resolved after the user activates the token,\r\n     * otherwise it will reject with a timeout error.\r\n     */\r\n    U2FAuth.prototype.authenticate = function (identity) {\r\n        return _super.prototype._authenticate.call(this, identity, Credential.U2F);\r\n    };\r\n    return U2FAuth;\r\n}(Authenticator));\r\nexport { U2FAuth };\r\n//# sourceMappingURL=auth.js.map"],"names":["HandshakeStep","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","HandshakeContext","maxRounds","serverHandle","clientHandle","nextStep","clientData","serverData","ContinueClient","ContinueServer","Error","InitClient","InitServer","withClientHandle","handle","withServerHandle","withServerData","data","withClientData","Authenticator","authService","authClient","_authenticate","identity","credential","server","client","Credential","User","Everyone","Authenticate","Ticket","then","ticket","jwt","Promise","reject","ctx","init","CreateAuthentication","continue","ContinueAuthentication","Base64Url","fromUtf8","result","status","AuthenticationStatus","Continue","authData","Completed","resolve","context","catch","err","finally","term","DestroyAuthentication","authenticate","_identify","cred","Identify","FingerPosition","SmartCardAuth","_super","call","cardData","SmartCard","ContactlessCardAuth","ContactlessCard","identify","ProximityCardAuth","ProximityCard","CustomAction","Finger","position","fromJson","json","FingerprintsAuth","getEnrolledFingers","user","GetEnrollmentData","Fingerprints","JSON","parse","Utf8","fromBase64Url","map","item","samples","WindowsAuth","IWA","SecurityQuestionsAuth","getEnrolledQuestions","SecurityQuestions","Utf16","obj","Question","answers","OTP","OneTimePassword","TimeOtpAuth","code","getUnlockCode","userOrSerialNumber","challenge","token","_a","o","n","m","Symbol","iterator","r","e","i","ar","next","done","push","value","error","__read","Anonymous","serialNumber","UnlockActiveIdHardwareToken","PushOtpAuth","SmsOtpAuth","sendChallenge","SendSMSRequest","None","EmailOtpAuth","SendEmailRequest","Password","HandshakeType","PasswordAuth","password","randomize","PasswordRandomization","reset","newPassword","PasswordReset","PinAuth","pin","PIN","FaceAuth","Face","HandshakeData","handshakeType","U2FClient","stringify","handshake","handshakeData","signRequest","u2fApi\r\n            .sign","signResponse","serialNum","version","appId","signatureData","response","fromUtf16","U2FAuth","isSupported","u2fApi.isSupported","getAppId","RequestAppId","U2F","AppId"],"mappings":"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"}