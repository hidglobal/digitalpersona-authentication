{"version":3,"file":"index.umd.min.js","sources":["../es6/private/handshake.js","../es6/tokens/fingerprints/data.js","../es6/tokens/otp/actions.js","../es6/tokens/password/actions.js","../es6/tokens/u2f/actions.js","../es6/tokens/u2f/data.js","../es6/private/authentication.js","../es6/tokens/otp/auth.js","../es6/tokens/password/auth.js","../es6/tokens/u2f/client.js","../es6/tokens/cards/auth.js","../es6/tokens/face/auth.js","../es6/tokens/fingerprints/auth.js","../es6/tokens/pin/auth.js","../es6/tokens/questions/auth.js","../es6/tokens/u2f/auth.js","../es6/tokens/iwa/auth.js"],"sourcesContent":["/** @internal */\r\nexport var HandshakeStep;\r\n(function (HandshakeStep) {\r\n    HandshakeStep[HandshakeStep[\"InitClient\"] = 0] = \"InitClient\";\r\n    HandshakeStep[HandshakeStep[\"InitServer\"] = 1] = \"InitServer\";\r\n    HandshakeStep[HandshakeStep[\"ContinueClient\"] = 2] = \"ContinueClient\";\r\n    HandshakeStep[HandshakeStep[\"ContinueServer\"] = 3] = \"ContinueServer\";\r\n})(HandshakeStep || (HandshakeStep = {}));\r\n/** @internal\r\nHolds intermediate authentication workflow data and ensures workflow invariants.\r\nThe authentication workflow essentially is a sequence of steps,\r\nwhere each step passes authentication data either from the client to the server,\r\nor from server to the client.\r\nThe direction of data transfer on each step is determined by availability of\r\ndata from an opposite side:\r\n* if serverData !== null, then next step is on a client side\r\n* if clientData !== null, then next step is on a server side\r\nInvariant: serverData and clientData must be never not-null at the same time\r\n(except on error).\r\n*/\r\nexport class HandshakeContext {\r\n    constructor(maxRounds = 3) {\r\n        this.serverHandle = 0;\r\n        this.clientHandle = 0;\r\n        this.maxRounds = maxRounds;\r\n    }\r\n    nextStep() {\r\n        return (!this.serverHandle) ? HandshakeStep.InitServer :\r\n            (!this.clientHandle) ? HandshakeStep.InitClient :\r\n                (!this.clientData && this.serverData) ? HandshakeStep.ContinueClient :\r\n                    (!this.serverData && this.clientData) ? HandshakeStep.ContinueServer :\r\n                        (() => { throw new Error(\"Invalid state\"); })();\r\n    }\r\n    withClientHandle(handle) {\r\n        this.clientHandle = handle;\r\n        this.serverData = null;\r\n        return this;\r\n    }\r\n    withServerHandle(handle) {\r\n        this.serverHandle = handle;\r\n        this.clientData = null;\r\n        return this;\r\n    }\r\n    withServerData(data) {\r\n        this.serverData = data;\r\n        this.clientData = null;\r\n        if (!this.serverData)\r\n            throw new Error(\"No server data\");\r\n        --this.maxRounds; // countdown on every server response\r\n        if (this.maxRounds <= 0)\r\n            throw new Error(\"Handshake stalled\");\r\n        return this;\r\n    }\r\n    withClientData(data) {\r\n        this.clientData = data;\r\n        this.serverData = null;\r\n        if (!this.clientData)\r\n            throw new Error(\"No client data\");\r\n        return this;\r\n    }\r\n}\r\n//# sourceMappingURL=handshake.js.map","/** Finger positions. */\r\nexport var FingerPosition;\r\n(function (FingerPosition) {\r\n    FingerPosition[FingerPosition[\"Unknown\"] = 0] = \"Unknown\";\r\n    FingerPosition[FingerPosition[\"RightThumb\"] = 1] = \"RightThumb\";\r\n    FingerPosition[FingerPosition[\"RightIndex\"] = 2] = \"RightIndex\";\r\n    FingerPosition[FingerPosition[\"RightMiddle\"] = 3] = \"RightMiddle\";\r\n    FingerPosition[FingerPosition[\"RightRing\"] = 4] = \"RightRing\";\r\n    FingerPosition[FingerPosition[\"RightLittle\"] = 5] = \"RightLittle\";\r\n    FingerPosition[FingerPosition[\"LeftThumb\"] = 6] = \"LeftThumb\";\r\n    FingerPosition[FingerPosition[\"LeftIndex\"] = 7] = \"LeftIndex\";\r\n    FingerPosition[FingerPosition[\"LeftMiddle\"] = 8] = \"LeftMiddle\";\r\n    FingerPosition[FingerPosition[\"LeftRing\"] = 9] = \"LeftRing\";\r\n    FingerPosition[FingerPosition[\"LeftLittle\"] = 10] = \"LeftLittle\";\r\n})(FingerPosition || (FingerPosition = {}));\r\n/** A finger enrollment data. */\r\nexport class Finger {\r\n    constructor(\r\n    /** A finger position. */\r\n    position) {\r\n        this.position = position;\r\n    }\r\n    /** Creates a finger enrollment data object from a plain JSON object. */\r\n    static fromJson(json) {\r\n        const obj = json;\r\n        return new Finger(obj.position);\r\n    }\r\n}\r\n//# sourceMappingURL=data.js.map","/**@internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"SendEmailVerificationRequest\"] = 16] = \"SendEmailVerificationRequest\";\r\n    CustomAction[CustomAction[\"SendSMSRequest\"] = 513] = \"SendSMSRequest\";\r\n    CustomAction[CustomAction[\"SendEmailRequest\"] = 514] = \"SendEmailRequest\";\r\n    CustomAction[CustomAction[\"UnlockActiveIdHardwareToken\"] = 515] = \"UnlockActiveIdHardwareToken\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","/**@internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"PasswordRandomization\"] = 4] = \"PasswordRandomization\";\r\n    CustomAction[CustomAction[\"PasswordReset\"] = 13] = \"PasswordReset\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","/**@internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"RequestAppId\"] = 17] = \"RequestAppId\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","/**@internal\r\n *\r\n */\r\nexport class ClientData {\r\n    constructor(type, challenge, origin) {\r\n        this.typ = type;\r\n        this.challenge = challenge;\r\n        this.origin = origin;\r\n    }\r\n    forAuthentication(challenge, origin) {\r\n        return new ClientData(\"navigator.id.getAssertion\", challenge, origin);\r\n    }\r\n    forEnrollment(challenge, origin) {\r\n        return new ClientData(\"navigator.id.finishEnrollment\", challenge, origin);\r\n    }\r\n}\r\n/**@internal\r\n *\r\n */\r\nexport var HandshakeType;\r\n(function (HandshakeType) {\r\n    HandshakeType[HandshakeType[\"ChallengeRequest\"] = 0] = \"ChallengeRequest\";\r\n    HandshakeType[HandshakeType[\"ChallengeResponse\"] = 1] = \"ChallengeResponse\";\r\n    HandshakeType[HandshakeType[\"AuthenticationRequest\"] = 2] = \"AuthenticationRequest\";\r\n    HandshakeType[HandshakeType[\"AuthenticationResponse\"] = 3] = \"AuthenticationResponse\";\r\n})(HandshakeType || (HandshakeType = {}));\r\nexport class HandshakeData {\r\n    constructor() {\r\n        this.handshakeType = 0 /* ChallengeRequest */;\r\n    }\r\n}\r\n//# sourceMappingURL=data.js.map","import { Ticket, User, Credential, Base64Url } from '@digitalpersona/core';\r\nimport { AuthenticationStatus } from '@digitalpersona/services';\r\nimport { HandshakeStep, HandshakeContext } from './handshake';\r\nexport class AuthenticationData {\r\n}\r\n/** @internal */\r\nexport class Authenticator {\r\n    constructor(authService, authClient) {\r\n        this.authService = authService;\r\n        this.authClient = authClient;\r\n        if (!this.authService)\r\n            throw new Error(\"authService\");\r\n    }\r\n    _authenticate(identity, credential) {\r\n        return authenticate(identity, credential, this.authService, this.authClient);\r\n    }\r\n    _identify(cred) {\r\n        return this.authService\r\n            .Identify(cred)\r\n            .then(ticket => ticket.jwt);\r\n    }\r\n}\r\n/** @internal */\r\nfunction authenticate(identity, credential, server, client) {\r\n    // When credential data are present, use a direct authentication flow\r\n    if (credential instanceof Credential) {\r\n        if (!identity)\r\n            identity = User.Everyone();\r\n        return (identity instanceof User\r\n            ? server.Authenticate(identity, credential)\r\n            : server.Authenticate(new Ticket(identity), credential)).then(ticket => ticket.jwt);\r\n    }\r\n    // When no credential data are present, use a challenge-response authentication flow\r\n    if (!client)\r\n        return Promise.reject(new Error(\"Client\"));\r\n    // Performs one step in an authentication workflow and recursively calls itself for a next step.\r\n    // The workflow finishes when a token obtained, or an error produced.\r\n    const nextStep = (ctx) => {\r\n        switch (ctx.nextStep()) {\r\n            case HandshakeStep.InitClient: {\r\n                return client\r\n                    .init()\r\n                    .then(data => nextStep(ctx.withClientHandle(data.handle).withClientData(data.data)));\r\n            }\r\n            case HandshakeStep.InitServer: {\r\n                return ((identity === null) || (identity instanceof User)\r\n                    ? server.CreateAuthentication(identity, credential)\r\n                    : server.CreateAuthentication(new Ticket(identity), credential))\r\n                    .then(handle => nextStep(ctx.withServerHandle(handle)));\r\n            }\r\n            case HandshakeStep.ContinueClient: {\r\n                return client\r\n                    .continue(ctx.clientHandle, ctx.serverData)\r\n                    .then(clientData => nextStep(ctx.withClientData(clientData)));\r\n            }\r\n            case HandshakeStep.ContinueServer: {\r\n                return server\r\n                    .ContinueAuthentication(ctx.serverHandle, Base64Url.fromUtf8(ctx.clientData))\r\n                    .then(result => {\r\n                    switch (result.status) {\r\n                        case AuthenticationStatus.Error:\r\n                            return Promise.reject(new Error(\"Authentication failed\"));\r\n                        case AuthenticationStatus.Continue:\r\n                            return nextStep(ctx.withServerData(result.authData));\r\n                        case AuthenticationStatus.Completed:\r\n                            return Promise.resolve(result.jwt);\r\n                        default:\r\n                            throw new Error(\"Unexpected status\");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    // Start the workflow and extract a token (or throw an error) when ready.\r\n    const context = new HandshakeContext();\r\n    return nextStep(context)\r\n        .catch(err => {\r\n        // somehow exception thrown inside u2fApi does not automatically reject the promise, so forcing this here\r\n        return Promise.reject(err);\r\n    })\r\n        .finally(() => {\r\n        if (context.clientHandle)\r\n            client.term(context.clientHandle); // ignore the outcome\r\n        if (context.serverHandle)\r\n            server.DestroyAuthentication(context.serverHandle); // ignore the outcome\r\n    });\r\n}\r\n//# sourceMappingURL=authentication.js.map","import { User, Ticket, Credential } from '@digitalpersona/core';\r\nimport { CustomAction } from './actions';\r\nimport { Authenticator } from '../../private';\r\nfunction OTP(data) {\r\n    return new Credential(Credential.OneTimePassword, data);\r\n}\r\n/**\r\n * Time-based one-time password (TOTP) authentication API.\r\n * TOTP supports only authentication. Identification is not supported.\r\n */\r\nexport class TimeOtpAuth extends Authenticator {\r\n    /** Constructs a new TOTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using user's TOTP code.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param code - a TOTP code.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, code) {\r\n        return super._authenticate(identity, OTP(code));\r\n    }\r\n    /** Creates a code allowing to unlock a hardware TOTP device when it locks after a number of\r\n     * unsuccessful PIN entries.\r\n     * @param userOrSerialNumber - a username or a locked device serial number.\r\n     * @param challenge - a challenge code provided by the locked device user.\r\n     * @param token - an optional JSON Web Token of the locked device user.\r\n     * @returns a promise to return an unlock code that the locked device user must type in.\r\n     */\r\n    getUnlockCode(userOrSerialNumber, challenge, token) {\r\n        const [user, serialNumber] = (userOrSerialNumber instanceof User)\r\n            ? [userOrSerialNumber, null]\r\n            : [User.Anonymous(), userOrSerialNumber];\r\n        return this.authService\r\n            .CustomAction(CustomAction.UnlockActiveIdHardwareToken, new Ticket(token || \"\"), user, OTP({ challenge, serialNumber }));\r\n    }\r\n}\r\n/**\r\n * A one-time password authentication API based on Push Notifications (Push OTP).\r\n * Push OTP supports only authentication. Identification is not supported.\r\n */\r\nexport class PushOtpAuth extends Authenticator {\r\n    /** Constructs a new Push OTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using a Push Notification on the user's registered mobile device.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used. To resolve the promise, the user must accept a Push Notification sent to their\r\n     * mobile device.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     *\r\n     * The user must have a mobile device with a DigitalPersona authenticator app installed and\r\n     * registered in the DigitalPersona server. The user will receive a Push Notification on their\r\n     * mobile device via the app and must accept the notification to proceed. The promise returned\r\n     * by the method will be resolved when the user accepts the notification, otherwise it will reject\r\n     * with a timeout error.\r\n     */\r\n    authenticate(identity) {\r\n        return super._authenticate(identity, OTP(\"push\"));\r\n    }\r\n}\r\n/**\r\n * A one-time password authentication API based on a Short Message Service (SMS OTP).\r\n * SMS OTP supports only authentication. Identification is not supported.\r\n */\r\nexport class SmsOtpAuth extends Authenticator {\r\n    /** Constructs a new SMS OTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Sends an SMS challenge with a OTP code to the user's registered mobile device.\r\n     * @param user - a name of the user\r\n     * @returns a promise to send the challenge code.\r\n     */\r\n    sendChallenge(user) {\r\n        return this.authService\r\n            .CustomAction(CustomAction.SendSMSRequest, Ticket.None(), user, OTP())\r\n            .then();\r\n    }\r\n    /** Authenticates the user using a challenge sent to the user's registered mobile device via SMS.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param code - a code the device user received via SMS challenge.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     *\r\n     * The user must have a mobile device with a phone number registered in the DigitalPersona server.\r\n     * The user will receive an SMS on their mobile device and must type the code sent with the message.\r\n     */\r\n    authenticate(identity, code) {\r\n        return super._authenticate(identity, OTP(code));\r\n    }\r\n}\r\n/**\r\n * A one-time password authentication API based on a electronic mail (Email OTP).\r\n * Email OTP supports only authentication. Identification is not supported.\r\n */\r\nexport class EmailOtpAuth extends Authenticator {\r\n    /** Constructs a new Email OTP authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Sends an e-mail challenge with a OTP code to the user's registered mobile device.\r\n     * @param user - a name of the user\r\n     * @returns a promise to send the challenge code to the registered e-mail address.\r\n     * Will reject if user has no email or in case of any other error.\r\n     * @remarks\r\n     * The user has to have an email registered in their LADP user record in ActiveDirectory or LDS.\r\n     * The server will look for a first entry in a `mail` LDAP atribute of the user record.\r\n     */\r\n    sendChallenge(user) {\r\n        return this.authService\r\n            .CustomAction(CustomAction.SendEmailRequest, Ticket.None(), user, OTP())\r\n            .then();\r\n    }\r\n    /** Authenticates the user using a challenge sent to the user's registered e-mail address.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param code - a code the user received via e-mail challenge.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a OTP was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, code) {\r\n        return super._authenticate(identity, OTP(code));\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import { Ticket, Credential } from '@digitalpersona/core';\r\nimport { CustomAction } from './actions';\r\nimport { Authenticator } from '../../private';\r\nfunction Password(data) {\r\n    return new Credential(Credential.Password, data);\r\n}\r\n/**\r\n * Password authentication API.\r\n * Passwords support only authentication. Identification is not supported.\r\n */\r\nexport class PasswordAuth extends Authenticator {\r\n    /** Constructs a new password authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using user's password.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param password - a user's password.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a password was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, password) {\r\n        return super._authenticate(identity, Password(password));\r\n    }\r\n    /** Creates a randomized user's password.\r\n     * @param user - a user's name.\r\n     * @param token - a JSON Web Token of a person initiating a password randomization.\r\n     * This person must have a privilege to randomize user passwords.\r\n     * @returns a promise to return a new randomized password.\r\n     * @remarks\r\n     * DigitalPersona AD Server supports password randomization only for ActiveDirectory users.\r\n     * DigitalPersona LDS Server supports password randomization only for DigitalPersona users (formerly \"Altus Users\").\r\n     */\r\n    randomize(user, token) {\r\n        return this.authService.CustomAction(CustomAction.PasswordRandomization, new Ticket(token), user, Password());\r\n    }\r\n    /** Resets user's password.\r\n     * @param user - a user's name.\r\n     * @param newPassword - a new password to replace the old password.\r\n     * @param token - a JSON Web Token of a person initiating a password reset.\r\n     * This person must have a privilege to set users' passwords.\r\n     * @returns a promise to reset user's password.\r\n     * @remarks\r\n     * DigitalPersona AD Server supports password randomization only for ActiveDirectory users.\r\n     * DigitalPersona LDS Server supports password randomization only for DigitalPersona users (formerly \"Altus Users\").\r\n     */\r\n    reset(user, newPassword, token) {\r\n        return this.authService.CustomAction(CustomAction.PasswordReset, new Ticket(token), user, Password(newPassword))\r\n            .then();\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import * as u2fApi from 'u2f-api';\r\nimport { Utf16, Base64Url } from '@digitalpersona/core';\r\nimport { HandshakeData } from './data';\r\n/**@internal\r\n *\r\n * Implements the client's part of the U2F handshake protocol.\r\n */\r\nexport class U2FClient {\r\n    init() {\r\n        const challenge = new HandshakeData();\r\n        return Promise.resolve({\r\n            handle: 1,\r\n            data: JSON.stringify(challenge)\r\n        });\r\n    }\r\n    continue(handle, data) {\r\n        const handshake = JSON.parse(data);\r\n        if (handshake.handshakeType != 1 /* ChallengeResponse */)\r\n            return Promise.reject(new Error(\"Unexpected handshake type\"));\r\n        if (!handshake.handshakeData)\r\n            return Promise.reject(new Error(\"No handshake data\"));\r\n        const signRequest = JSON.parse(Utf16.fromBase64Url(handshake.handshakeData));\r\n        return u2fApi\r\n            .sign(signRequest)\r\n            .then(signResponse => {\r\n            const handshakeData = JSON.stringify({\r\n                serialNum: \"\",\r\n                version: signRequest.version,\r\n                appId: signRequest.appId,\r\n                signatureData: signResponse.signatureData,\r\n                clientData: signResponse.clientData\r\n            });\r\n            var response = {\r\n                handshakeType: 2 /* AuthenticationRequest */,\r\n                handshakeData: Base64Url.fromUtf16(handshakeData)\r\n            };\r\n            return JSON.stringify(response);\r\n        });\r\n    }\r\n    term(handle) {\r\n        // nothing to do, the handle is surrogate\r\n        return Promise.resolve();\r\n    }\r\n}\r\n//# sourceMappingURL=client.js.map","import { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Smart card authentication API.\r\n * Smartcards supports only authentication with PIN. Identification is not supported.\r\n */\r\nexport class SmartCardAuth extends Authenticator {\r\n    /** Constructs a new smartcard authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using a smartcard.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param cardData - card authentication data received from the card using a PIN.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a smartcard was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, cardData) {\r\n        return super._authenticate(identity, new Credential(Credential.SmartCard, cardData));\r\n    }\r\n}\r\n/**\r\n * Contactless card authentication API.\r\n * Contactless cards support both authentication and identification.\r\n */\r\nexport class ContactlessCardAuth extends Authenticator {\r\n    /** Constructs a new contactless authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using a contactless card.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a contactless card was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, cardData) {\r\n        return super._authenticate(identity, new Credential(Credential.ContactlessCard, cardData));\r\n    }\r\n    /** Identifies the user with a contactless card.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a subject identity claims (`sub`, `group`, etc)\r\n     * and a claim (`crd`) showing the fact a contactless card was used.\r\n     * Will reject if identification fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    identify(cardData) {\r\n        return this.authService\r\n            .Identify(new Credential(Credential.ContactlessCard, cardData))\r\n            .then(ticket => ticket.jwt);\r\n    }\r\n}\r\n/**\r\n * Proximity card authentication API.\r\n * Proximity cards support both authentication and identification.\r\n */\r\nexport class ProximityCardAuth extends Authenticator {\r\n    /** Constructs a new proximity authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using a proximimty card.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a proximity card was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, cardData) {\r\n        return super._authenticate(identity, new Credential(Credential.ProximityCard, cardData));\r\n    }\r\n    /** Identifies the user with a proximity card.\r\n     * @param cardData - card authentication data received from the card using a `CardsReader.getCardAuthData`.\r\n     * @returns a promise to return a JSON Web Token containing a subject identity claims (`sub`, `group`, etc)\r\n     * and a claim (`crd`) showing the fact a proximity card was used.\r\n     * Will reject if identification fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    identify(cardData) {\r\n        return this.authService\r\n            .Identify(new Credential(Credential.ProximityCard, cardData))\r\n            .then(ticket => ticket.jwt);\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Face authentication API.\r\n * Face credential supports authentication. Identification is currently not supported by the server.\r\n */\r\nexport class FaceAuth extends Authenticator {\r\n    /** Constructs a new face authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using their face images.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param samples - a collection of biometric samples with face images.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a face was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, samples) {\r\n        return super._authenticate(identity, new Credential(Credential.Face, samples));\r\n    }\r\n    /** Currently face identification is not supported by the server. */\r\n    identify(samples) {\r\n        return super._identify(new Credential(Credential.Face, samples));\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import { Utf8, Credential } from '@digitalpersona/core';\r\nimport { Finger } from './data';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Fingerprint authentication API.\r\n * Fingerprints support both authentication and identification.\r\n */\r\nexport class FingerprintsAuth extends Authenticator {\r\n    /** Constructs a new fingerprint authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Reads a list of fingers currently enrolled by the user.\r\n     * @param user - a user name\r\n     * @returns a promise to return a list of enrolled fingers.\r\n     * If no fingers are enrolled, an emty list will be returned.\r\n     * May reject if the user is unknown or in case of an error.\r\n     */\r\n    getEnrolledFingers(user) {\r\n        return this.authService\r\n            .GetEnrollmentData(user, Credential.Fingerprints)\r\n            .then(data => JSON.parse(Utf8.fromBase64Url(data))\r\n            .map(item => Finger.fromJson(item)));\r\n    }\r\n    /** Authenticates the user using their fingerprint samples.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param samples - a collection of biometric samples with fingerprint scans.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a fingerprint was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, samples) {\r\n        return super._authenticate(identity, new Credential(Credential.Fingerprints, samples));\r\n    }\r\n    /** Identifies the user with their fingerprints.\r\n     * @param samples - a collection of biometric samples with fingerprint scans.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a fingerprint was used.\r\n     * Will reject if identification fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    identify(samples) {\r\n        return super._identify(new Credential(Credential.Fingerprints, samples));\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Personal Identification Number (PIN) authentication API.\r\n * PIN support only authentication. Identification is not supported.\r\n */\r\nexport class PinAuth extends Authenticator {\r\n    /** Constructs a new PIN authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Authenticates the user using user's PIN code.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param pin - a user's PIN.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a PIN was used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, pin) {\r\n        return super._authenticate(identity, new Credential(Credential.PIN, pin));\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import { Credential, Utf16, Question } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Security Questions authentication API.\r\n * Security Questions support only authentication. Identification is not supported.\r\n */\r\nexport class SecurityQuestionsAuth extends Authenticator {\r\n    /** Constructs a new Security Questions authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService);\r\n    }\r\n    /** Reads a list of security questions enrolled by the user.\r\n     * @param user - a user's name.\r\n     * @returns a promise to return a list of enrolled questions.\r\n     */\r\n    getEnrolledQuestions(user) {\r\n        return this.authService\r\n            .GetEnrollmentData(user, Credential.SecurityQuestions)\r\n            .then(data => JSON.parse(Utf16.fromBase64Url(data))\r\n            .map(obj => Question.fromJson(obj)));\r\n    }\r\n    /** Authenticates the user using user's answers to security questions.\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @param answers - user's answers to security questions.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a Security Questions were used.\r\n     * Will reject if authentication fails.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     */\r\n    authenticate(identity, answers) {\r\n        return super._authenticate(identity, new Credential(Credential.SecurityQuestions, { answers }));\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import * as u2fApi from 'u2f-api';\r\nimport { User, Credential, Ticket } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\nimport { CustomAction } from './actions';\r\nimport { U2FClient } from './client';\r\n/**\r\n * Universal Second Factor (U2F) authentication API.\r\n * U2F support only authentication. Identification is not supported.\r\n */\r\nexport class U2FAuth extends Authenticator {\r\n    /** Constructs a new U2F authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService) {\r\n        super(authService, new U2FClient());\r\n    }\r\n    /** Checks is the U2F supported on this platform.\r\n     * @returns a promise to return `true` is the platform supports U2F or `false` otherwise.\r\n     * @remarks\r\n     * To support U2F the user agent must have required API, the web site must use HTTPS,\r\n     * and the DigitalPersona Web Components server must have properly configured U2F AppId\r\n     * for the site.\r\n     */\r\n    static isSupported() {\r\n        return u2fApi.isSupported();\r\n    }\r\n    /** Reads U2F AppID endpoint URL.\r\n     * @returns a promise to return a U2F AppID endpoint URL.\r\n     */\r\n    getAppId() {\r\n        return this.authService.CustomAction(CustomAction.RequestAppId, Ticket.None(), User.Anonymous(), new Credential(Credential.U2F, \"\")).then(data => JSON.parse(data).AppId);\r\n    }\r\n    /** Authenticates the user using a user's registered U2F token (FIDO token).\r\n     * @param identity - a {@link User |username} or a JSON Web Token.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a U2F was used. To resolve the promise, the user must touch the U2F token when prompted.\r\n     * Will reject if authentication fails or times out.\r\n     * @remarks\r\n     * If the `identity` parameter is a user name, a new token will be created.\r\n     * If the `identity` parameter is a JSON Web Token, an updated token will be returned.\r\n     *\r\n     * The user must have a U2F (FIDO) token enrolled in the DigitalPersona server.\r\n     * The user should insert the token and activate it using a touch or pressing a device button.\r\n     * The promise returned by the method will be resolved after the user activates the token,\r\n     * otherwise it will reject with a timeout error.\r\n     */\r\n    authenticate(identity) {\r\n        return super._authenticate(identity, Credential.U2F);\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map","import { Credential } from '@digitalpersona/core';\r\nimport { Authenticator } from '../../private';\r\n/**\r\n * Integrated Windows authentication API.\r\n * IWA support only authentication. Identification is not supported.\r\n */\r\nexport class WindowsAuth extends Authenticator {\r\n    /** Constructs a new integrated Windows authentication API object.\r\n     * @param authService - an {@link AuthService|authentication service client} connected to the server.\r\n     */\r\n    constructor(authService, client) {\r\n        super(authService, client);\r\n    }\r\n    /** Authenticates using a currently logged Windows user.\r\n     * @returns a promise to return a JSON Web Token containing a claim (`crd`) showing the fact\r\n     * a currently logged Window account was used.\r\n     * Will reject if authentication fails.\r\n     */\r\n    authenticate() {\r\n        return super._authenticate(null, Credential.IWA);\r\n    }\r\n}\r\n//# sourceMappingURL=auth.js.map"],"names":["HandshakeStep","FingerPosition","CustomAction","HandshakeType","HandshakeContext","[object Object]","maxRounds","this","serverHandle","clientHandle","clientData","serverData","ContinueClient","ContinueServer","Error","InitClient","InitServer","handle","data","Authenticator","authService","authClient","identity","credential","server","client","Credential","User","Everyone","Authenticate","Ticket","then","ticket","jwt","Promise","reject","nextStep","ctx","init","withClientHandle","withClientData","CreateAuthentication","withServerHandle","continue","ContinueAuthentication","Base64Url","fromUtf8","result","status","AuthenticationStatus","Continue","withServerData","authData","Completed","resolve","context","catch","err","finally","term","DestroyAuthentication","authenticate","cred","Identify","Finger","position","json","OTP","OneTimePassword","Password","HandshakeData","handshakeType","U2FClient","challenge","JSON","stringify","handshake","parse","handshakeData","signRequest","Utf16","fromBase64Url","u2fApi\r\n            .sign","signResponse","serialNum","version","appId","signatureData","response","fromUtf16","super","cardData","_authenticate","ContactlessCard","user","SendEmailRequest","None","code","samples","Face","_identify","GetEnrollmentData","Fingerprints","Utf8","map","item","fromJson","password","token","PasswordRandomization","newPassword","PasswordReset","pin","PIN","ProximityCard","SecurityQuestions","obj","Question","answers","SmartCard","SendSMSRequest","userOrSerialNumber","serialNumber","Anonymous","UnlockActiveIdHardwareToken","u2fApi.isSupported","RequestAppId","U2F","AppId","IWA"],"mappings":"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"}